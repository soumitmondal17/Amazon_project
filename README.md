## Amazon Project
Difficulty Level: Advanced

ðŸ“Š **Project Overview**
This project analyzes a dataset of sales records from an Amazonâ€‘like eâ€‘commerce platform. It demonstrates advanced SQL proficiency through extensive querying of customer behavior, product performance, and sales trends using PostgreSQL.
Key highlights:
- Tackled complex SQL problems such as revenue analysis, customer segmentation, and inventory management.
- Designed and implemented real-world business scenarios using structured queries and stored procedures.
- Included an ERD diagram to visually represent the database schema and table relationships.

ðŸ—„ï¸ **Database Setup and Design**
- The database contains 8 tables: customers, sellers, products, orders, order_items, inventory, payments, and shippings.
- Tables are designed with primary keys, foreign key constraints, and indexing to ensure integrity and optimize query performance.

ðŸŽ¯ **Objective**
The primary objective is to showcase SQL mastery through complex queries that solve real-world eâ€‘commerce challenges. The analysis covers:
- Customer behavior
- Sales trends
- Inventory management
- Payment and shipping analysis
- Revenue analysis by product categories

ðŸ”Ž **Identifying Business Problems**
This repository documents business questions and their corresponding SQL solutions, demonstrating how structured queries can be applied to solve practical challenges in an eâ€‘commerce environment.

- Top selling products 
Query the top 10 selling products by total sales value. 
Challange: Include Product name, total quantity sold, and total sales value.
```sql
SELECT p.product_name, SUM(oi.quantity) AS total_quantity,
       SUM(oi.total_sales) AS total_sales
FROM products p
JOIN order_items oi ON p.product_id = oi.product_id
GROUP BY p.product_name
ORDER BY total_sales DESC;
```
-Revenue by category.
Calculate the total revenue generated by each category.
Challange: Include the percentage contribution of each category to total revenue.
```sql
SELECT c.category_name, COALESCE(SUM(total_sales),0) AS total_revenue,
       ROUND(
           COALESCE(SUM(total_sales),0)*100.0 / SUM(COALESCE(SUM(total_sales),0)) OVER()
       ) AS pct_contribution
FROM category c
JOIN products p ON c.category_id = p.category_id
LEFT JOIN order_items oi ON oi.product_id = p.product_id
GROUP BY c.category_name
ORDER BY pct_contribution DESC;
```
-Average order value (AOV).
Commpute the average order value of each customer.
Challange: Include customers with more than 5 orders.
```sql
SELECT c.full_name, COUNT(oi.order_id) AS count_of_orders,
       ROUND(SUM(total_sales) / COUNT(oi.order_id), 2) AS average_order_value
FROM customers c
JOIN orders o ON c.customer_id = o.customer_id
JOIN order_items oi ON o.order_id = oi.order_id
GROUP BY 1
HAVING COUNT(oi.order_id) > 5
ORDER BY average_order_value DESC;
```
-Monthly sales trend.
Query monthly total sales over the past year.
Challange: Display the sales trend, grouping by month, return current month sale, last month sale.  
```sql
SELECT 
    month, year, total_sales AS current_month_sales,
    LAG(total_sales, 1) OVER(ORDER BY month, year) AS previous_month_sales,
    COALESCE(total_sales - LAG(total_sales, 1) OVER(ORDER BY month, year), 0) AS change,
    ROUND(
        COALESCE(total_sales - LAG(total_sales, 1) OVER(ORDER BY month, year), 0)
        / NULLIF(LAG(total_sales, 1) OVER(ORDER BY month, year), 0) * 100.00,
        2
    ) AS pct_change
FROM (
    SELECT EXTRACT(YEAR FROM o.order_date) AS year,
           EXTRACT(MONTH FROM o.order_date) AS month,
           SUM(oi.total_sales) AS total_sales
    FROM orders o
    JOIN order_items oi ON o.order_id = oi.order_id
    WHERE o.order_date >= CURRENT_DATE - INTERVAL '1 year'
    GROUP BY 1, 2
    ORDER BY 1, 2 DESC
) AS t1;
```
-Customers with no purchases.
Find out the customers who have registered but never placed an order.
Challange: List customer details.
```sql
SELECT *
FROM customers
WHERE customer_id NOT IN (
    SELECT customer_id FROM orders
);
````
-Best selling categories by state. 
Identify the best selling product category for each state.
Challange: Include total sales for that category within each state. 
```sql
-- Approach 1 using CTE

WITH category_sales AS 
    (SELECT c1.category_id, c1.category_name, c2.state, COALESCE(SUM(oi.total_sales),0) AS total_sales 
     FROM category c1
     JOIN products p ON c1.category_id = p.category_id
     LEFT JOIN order_items oi ON oi.product_id = p.product_id
     LEFT JOIN orders o ON o.order_id = oi.order_id
     LEFT JOIN customers c2 ON c2.customer_id = o.customer_id
     GROUP BY 1,2,3)
SELECT state, category_name, total_sales
FROM (
    SELECT state, category_name, total_sales,
           RANK() OVER(PARTITION BY state ORDER BY total_sales DESC) AS rnk
    FROM category_sales
) ranked 
WHERE rnk = 1 
ORDER BY state;

-- Approach 2 using DISTINCT function.

SELECT DISTINCT ON (c2.state)
    c2.state,
    c1.category_name,
    COALESCE(SUM(oi.total_sales),0) AS total_sales
FROM category c1
    JOIN products p ON c1.category_id = p.category_id
    LEFT JOIN order_items oi ON oi.product_id = p.product_id
    LEFT JOIN orders o ON o.order_id = oi.order_id
    LEFT JOIN customers c2 ON c2.customer_id = o.customer_id
GROUP BY 1,2
ORDER BY c2.state, COALESCE(SUM(oi.total_sales),0) DESC;
```
-Customer lifetime value (CLTV). 
Calculate total value of orders placed by each customers over their lifetime.
Challange: Rank customers based on their CLTV. 
```sql
SELECT c.customer_id, c.full_name, COALESCE(SUM(oi.total_sales),0) AS total_value,
       DENSE_RANK() OVER(ORDER BY SUM(oi.total_sales) DESC) AS CLTV
FROM customers c 
LEFT JOIN orders o ON c.customer_id = o.customer_id
LEFT JOIN order_items oi ON oi.order_id = o.order_id
GROUP BY 1,2
ORDER BY total_value DESC;
```
- Inventory stock alerts. 
Query products with stock levels below a certain threshold (e.g., less than 10 units).
Challange: Include last restock date and wearhouse information.
```sql
SELECT p.product_id, p.product_name, i.warehouse_id, i.last_stock_date
FROM inventory i
JOIN products p ON p.product_id = i.product_id
WHERE i.stock <= 10;
```
-Shipping delays. 
Identify orders where the shipping date is later than 7 days after the order date.
Challange: Include customer, order details and delivery provider.  
```sql
SELECT c.full_name, p.product_name, o.order_date, s.shipping_provider,
       s.shipping_date - o.order_date AS delayed_shipping_days
FROM order_items oi
JOIN products p ON p.product_id = oi.product_id
JOIN orders o ON o.order_id = oi.order_id
JOIN customers c ON c.customer_id = o.customer_id
JOIN shippings s ON s.order_id = o.order_id
WHERE s.shipping_date - o.order_date >= 7
ORDER BY delayed_shipping_days;
```
-Payment success rate. 
Calculate the percentage of succesful payments accross all orders. 
Challange: Include breakowns by payment status (eg.,completed, pending etc.) 
```sql
SELECT 
    p.payment_status,
    COUNT(*) AS total_orders,
    ROUND(100.0 * COUNT(*) / SUM(COUNT(*)) OVER(), 2) AS percentage
FROM payment p
GROUP BY p.payment_status
ORDER BY percentage DESC;
```
-Top performing sellers. 
Find the top performing sellers based on total sales value.
Challange: Include both success and failed orders and display their percentage of orders.  
```sql
-- Using SUM OVER()
WITH top_sellers AS 
    (SELECT s.seller_id, s.seller_name, SUM(oi.total_sales) AS total_sales 
     FROM sellers s
     JOIN orders o ON o.seller_id = s.seller_id
     JOIN order_items oi ON oi.order_id = o.order_id
     GROUP BY s.seller_id, s.seller_name
     ORDER BY total_sales DESC
     LIMIT 5)
SELECT
    ts.seller_id, ts.seller_name, ts.total_sales, o.order_status,
    COUNT(*) AS total_orders,
    ROUND((100 * COUNT(*) / SUM(COUNT(*)) OVER(PARTITION BY ts.seller_id)), 2) AS pct_orders
FROM top_sellers ts
JOIN orders o ON o.seller_id = ts.seller_id
GROUP BY ts.seller_id, ts.seller_name, o.order_status, ts.total_sales
ORDER BY total_sales DESC, pct_orders DESC;

-- Using CASE function
WITH top_sellers AS 
    (SELECT s.seller_id, s.seller_name, SUM(oi.total_sales) AS total_sales 
     FROM sellers s
     JOIN orders o ON o.seller_id = s.seller_id
     JOIN order_items oi ON oi.order_id = o.order_id
     GROUP BY s.seller_id, s.seller_name
     ORDER BY total_sales DESC
     LIMIT 5)
SELECT
    ts.seller_id, ts.seller_name, ts.total_sales,
    COUNT(*) AS total_orders,
    SUM(CASE WHEN o.order_status = 'Inprogress' THEN 1 ELSE 0 END) AS incomplete_orders,
    SUM(CASE WHEN o.order_status = 'Completed' THEN 1 ELSE 0 END) AS completed_orders,
    ROUND((100 * SUM(CASE WHEN o.order_status = 'Completed' THEN 1 ELSE 0 END) / COUNT(*)), 2) AS success_rate
FROM top_sellers ts
JOIN orders o ON o.seller_id = ts.seller_id
GROUP BY ts.seller_id, ts.seller_name, ts.total_sales
ORDER BY total_sales DESC, success_rate DESC;
```
-Calculate profit margin. 
Calculate the profit margin for each product. 
Challange: Rank products by their profit margin, showing highest to lowest orders.  
```sql
SELECT
    product_name,
    profit_margin,
    DENSE_RANK() OVER(ORDER BY profit_margin DESC) AS product_rank
FROM
    (SELECT p.product_name,
            ROUND(((SUM((oi.price_per_unit - p.cogs) * oi.quantity) * 100.0) / SUM(oi.total_sales))::NUMERIC, 2) AS profit_margin
     FROM products p
     JOIN order_items oi ON p.product_id = oi.product_id
     GROUP BY 1
     ORDER BY 2 DESC) AS t1;
```
-Most returned products. 
Query top 10 products by the number of returns
Challange: Display the return rate as a percentage of total units sold for each product.
```sql
SELECT 
    p.product_id,
    p.product_name,
    SUM(CASE WHEN o.order_status = 'Returned' THEN oi.quantity ELSE 0 END) AS total_returns,
    SUM(oi.quantity) AS total_sold,
    ROUND(
        SUM(CASE WHEN o.order_status = 'Returned' THEN oi.quantity ELSE 0 END) * 100.0 
        / NULLIF(SUM(oi.quantity),0), 
        2
    ) AS return_rate_pct
FROM products p
JOIN order_items oi ON p.product_id = oi.product_id
JOIN orders o ON oi.order_id = o.order_id
GROUP BY p.product_id, p.product_name
ORDER BY total_returns DESC
LIMIT 10;
```
-Inactive sellers. 
Identify sellers who have not made any sales in last 6 months. 
Challange: Show the last sale date and total sales from those sellers.
```sql
SELECT 
    s.seller_id,
    s.seller_name,
    MAX(o.order_date) AS last_sale_date,
    SUM(oi.total_sales) AS total_sales
FROM sellers s
JOIN orders o ON o.seller_id = s.seller_id
JOIN order_items oi ON oi.order_id = o.order_id
GROUP BY s.seller_id, s.seller_name
HAVING MAX(o.order_date) <= CURRENT_DATE - INTERVAL '6 months'
ORDER BY last_sale_date;
```
-Identify if the customer is returning or new. 
If the customer has done more than 5 reuturns, categorize them as returning otherwise new.
Challange: List customer ID, name, total orders, total returns.
```sql
SELECT c.customer_id, c.full_name, COUNT(o.order_id) AS total_orders,
       SUM(CASE WHEN order_status = 'Returned' THEN 1 ELSE 0 END) AS total_returns,
       CASE WHEN SUM(CASE WHEN order_status = 'Returned' THEN 1 ELSE 0 END) > 5 
            THEN 'Returning' ELSE 'New' END AS customer_category
FROM orders o 
JOIN customers c ON c.customer_id = o.customer_id
JOIN order_items oi ON oi.order_id = o.order_id
GROUP BY 1,2
ORDER BY total_returns DESC;
```
-Revenue by shipping provider. 
Calculte the total revenue handled by each shipping provider. 
Challange: Include the total number of orders handled and average delivery time for each provider.
```sql
SELECT 
    sp.shipping_provider,
    SUM(oi.total_sales) AS total_revenue,
    COUNT(DISTINCT o.order_id) AS total_orders,
    ROUND(AVG(sp.shipping_date - o.order_date), 2) AS avg_delivery_time_days,
	dense_rank() over(order by AVG(sp.shipping_date - o.order_date) desc) as rnk
FROM shippings sp
JOIN orders o 
    ON sp.order_id = o.order_id
JOIN order_items oi 
    ON o.order_id = oi.order_id
GROUP BY sp.shipping_provider
ORDER BY total_revenue DESC, rnk desc;
```
-Top 10 products with highest decreasing revenue ratio compare to last year and current year. 
Challange: Return product_id, product_name, category_name, last year revenue and current year revenue 
decrease ratio at the end round the results.
Note: Decrease ratio = cr-ls/ls* 100(cs=current_year-last_year)
```sql
WITH current_year_revenue AS
    (SELECT 
         p.product_id,
         p.product_name, 
         SUM(oi.total_sales) AS total_revenue
     FROM orders o
     JOIN order_items oi ON oi.order_id = o.order_id
     JOIN products p ON p.product_id = oi.product_id
     WHERE EXTRACT(YEAR FROM o.order_date) = 2025
     GROUP BY 1,2),

last_year_revenue AS
    (SELECT 
         p.product_id,
         p.product_name, 
         SUM(oi.total_sales) AS total_revenue
     FROM orders o
     JOIN order_items oi ON oi.order_id = o.order_id
     JOIN products p ON p.product_id = oi.product_id
     WHERE EXTRACT(YEAR FROM o.order_date) = 2024
     GROUP BY 1,2)

SELECT 
    cs.product_id,
    cs.product_name,
    ls.total_revenue AS last_year_revenue,
    cs.total_revenue AS current_year_revenue,
    (ls.total_revenue - cs.total_revenue) AS diff_revenue,
    ROUND(((ls.total_revenue - cs.total_revenue) / NULLIF(ls.total_revenue,0) * 100)::NUMERIC, 2) AS rev_pct_change
FROM last_year_revenue ls
JOIN current_year_revenue cs ON cs.product_id = ls.product_id
ORDER BY 6 DESC;
```
-**Final task**. 
--**Store Procedure**
Create a function as soon as the product is sold the same quantity should be reduced from inventory.
After any sales record it should update stock in inventory table based on product and quantity purchased.
-- ============================================================
-- Procedure: add_sales
-- Purpose  : Handles new sales transactions by:
--              1. Validating product availability in inventory
--              2. Recording order and order_items details
--              3. Updating inventory stock levels
--              4. Providing user-friendly notices
-- ============================================================
```sql
CREATE OR REPLACE PROCEDURE add_sales
(
    p_order_id       INT,
    p_customer_id    INT,
    p_seller_id      INT,
    p_order_item_id  INT,
    p_product_id     INT,
    p_quantity       INT
)
LANGUAGE plpgsql
AS $$

DECLARE 
    v_product_id   INT;
    v_product_name VARCHAR(50);
    v_count        INT;
    v_price        FLOAT;

BEGIN
    -- Step 1: Collect product details for reference
    SELECT price, product_id, product_name
        INTO v_price, v_product_id, v_product_name
    FROM products
    WHERE product_id = p_product_id;

    -- Step 2: Check product availability in inventory
    SELECT COUNT(*)
        INTO v_count
    FROM inventory
    WHERE product_id = p_product_id
      AND stock >= p_quantity;

    -- Step 3: If product is available, process the order
    IF v_count > 0 THEN    
        -- Insert into orders table
        INSERT INTO orders(order_id, order_date, customer_id, seller_id)
        VALUES(p_order_id, CURRENT_DATE, p_customer_id, p_seller_id);

        -- Insert into order_items table
        INSERT INTO order_items(order_item_id, order_id, product_id, quantity, price_per_unit, total_sales)
        VALUES(p_order_item_id, p_order_id, p_product_id, p_quantity, v_price, v_price * p_quantity);

        -- Update inventory stock
        UPDATE inventory
        SET stock = stock - p_quantity
        WHERE product_id = p_product_id;

        -- Success notice
        RAISE NOTICE 'Product : % has been added and inventory table has been updated.', v_product_name;

    ELSE
        -- Failure notice if product not available
        RAISE NOTICE 'The product: % is not available at this moment.', v_product_name;
    END IF;

END; 
$$
```
***Key Learnings***
Through this project, I strengthened my expertise in:
**Advanced SQL techniques:**
- Window functions (RANK, DENSE_RANK, LAG, LEAD) for trend and ranking analysis
- Aggregate functions with OVER() for distribution and contribution metrics
- Complex joins and subqueries for multi-table analysis
**Database design & optimization:**
- Normalized schema design across 8 interconnected tables
- Use of primary/foreign keys and indexing to ensure integrity and performance
- Writing stored procedures (PL/pgSQL) to automate business workflows
**Business problem solving:**
- Revenue analysis by product, category, and seller
- Customer segmentation (CLTV, returning vs. new customers)
- Inventory management and delayed shipping detection
- Success rate tracking for sellers and shipping providers
**Professional portfolio building:**
- Documented queries with recruiter-friendly explanations
- Created ERD diagrams to visualize schema relationships
- Framed technical work in terms of real-world business impact

